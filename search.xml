<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F07%2F21%2F2018-05-16-Mysql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[&lt;!DOCTYPE html&gt; zhangjinmiao.github.io/2018-05-16-Mysql分库分表中间件.md at 444c91a5a1049ef043d2321f32c44628b7004182 · zhangjinmiao/zhangjinmiao.github.io Skip to content In this repository All GitHub ↵ Jump to ↵ No suggested jump to results In this repository All GitHub ↵ Jump to ↵ In this repository All GitHub ↵ Jump to ↵ Dashboard Pull requests Issues Marketplace Explore LouisTuo Sign out zhangjinmiao / zhangjinmiao.github.io New repository Import repository New gist New organization This repository New issue Signed in as LouisTuo 🎯 Focusing Edit status 🎯 🎯 Could not update your status, please try again. 80 remaining Suggestions: 🌴 On vacation 🤒 Out sick 🏠 Working from home 🎯 Focusing Busy When others mention you, assign you, or request your review, GitHub will let them know that you have limited availability. Clear status Never Never Keep this status until you clear your status or edit your status. in 30 minutes in 1 hour in 4 hours today this week Set status Clear status Your profile Your repositories Your projects Your stars Your gists Help Settings Sign out Watch Notifications Not watching Be notified only when participating or @mentioned. Watch Releases only Be notified of new releases, and when participating or @mentioned. Unwatch releases Watching Be notified of all conversations. Unwatch Ignoring Never be notified. Stop ignoring 1 Unstar 0 Star 0 Fork 0 zhangjinmiao/zhangjinmiao.github.io Code Issues 0 Pull requests 0 Projects 0 Wiki Security Insights Code Issues 0 Pull requests 0 Projects 0 Wiki Security Pulse Community Permalink Tree: 444c91a5a1 Find file Copy path zhangjinmiao.github.io/_posts/mysql/2018-05-16-Mysql分库分表中间件.md Find file Copy path Fetching contributors&hellip; Cannot retrieve contributors at this time 27 lines (18 sloc) 637 Bytes Raw Blame History layout title categories description keywords post MySQL 分库分表中间件 MySQL mysql mysql, 分库分表 数据库中间件金山的 kingshard百度的 heisenberg58 同城的 Oceanus360 的 Atlas美团点评的 DBProxyMycatmysql-proxy分布式数据库TiDB Go &copy; 2019 GitHub, Inc. Terms Privacy Security Status Help Contact GitHub Pricing API Training Blog About You can’t perform that action at this time. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F07%2F21%2F2018-04-24-58%E5%88%B0%E5%AE%B6MySQL%E5%86%9B%E8%A7%84%E5%8D%87%E7%BA%A7%E7%89%88%2F</url>
    <content type="text"><![CDATA[&lt;!DOCTYPE html&gt; zhangjinmiao.github.io/2018-04-24-58到家MySQL军规升级版.md at 444c91a5a1049ef043d2321f32c44628b7004182 · zhangjinmiao/zhangjinmiao.github.io Skip to content In this repository All GitHub ↵ Jump to ↵ No suggested jump to results In this repository All GitHub ↵ Jump to ↵ In this repository All GitHub ↵ Jump to ↵ Dashboard Pull requests Issues Marketplace Explore LouisTuo Sign out zhangjinmiao / zhangjinmiao.github.io New repository Import repository New gist New organization This repository New issue Signed in as LouisTuo 🎯 Focusing Edit status 🎯 🎯 Could not update your status, please try again. 80 remaining Suggestions: 🌴 On vacation 🤒 Out sick 🏠 Working from home 🎯 Focusing Busy When others mention you, assign you, or request your review, GitHub will let them know that you have limited availability. Clear status Never Never Keep this status until you clear your status or edit your status. in 30 minutes in 1 hour in 4 hours today this week Set status Clear status Your profile Your repositories Your projects Your stars Your gists Help Settings Sign out Watch Notifications Not watching Be notified only when participating or @mentioned. Watch Releases only Be notified of new releases, and when participating or @mentioned. Unwatch releases Watching Be notified of all conversations. Unwatch Ignoring Never be notified. Stop ignoring 1 Unstar 0 Star 0 Fork 0 zhangjinmiao/zhangjinmiao.github.io Code Issues 0 Pull requests 0 Projects 0 Wiki Security Insights Code Issues 0 Pull requests 0 Projects 0 Wiki Security Pulse Community Permalink Tree: 444c91a5a1 Find file Copy path zhangjinmiao.github.io/_posts/mysql/2018-04-24-58到家MySQL军规升级版.md Find file Copy path zhangjinmiao guifan 444c91a Mar 23, 2019 1 contributor Users who have contributed to this file 214 lines (115 sloc) 5.36 KB Raw Blame History layout title categories description keywords post 58 到家 MySQL 军规升级版 MySQL mysql 58, mysql 一、基础规范表存储引擎必须使用 InnoDB 表字符集默认使用 utf8，必要时候使用 utf8mb4解读：（1）通用，无乱码风险，汉字 3 字节，英文 1 字节（2）utf8mb4 是 utf8 的超集，有存储 4 字节例如表情符号时，使用它 禁止使用存储过程，视图，触发器，Event解读：（1）对数据库性能影响较大，互联网业务，能让站点层和服务层干的事情，不要交到数据库层（2）调试，排错，迁移都比较困难，扩展性较差 禁止在数据库中存储大文件，例如照片，可以将大文件存储在对象存储系统，数据库中存储路径禁止在线上环境做数据库压力测试测试，开发，线上数据库环境必须隔离 二、命名规范库名，表名，列名必须用小写，采用下划线分隔解读：abc，Abc，ABC 都是给自己埋坑 库名，表名，列名必须见名知义，长度不要超过 32 字符解读：tmp，wushan 谁 TM 知道这些库是干嘛的 库备份必须以 bak 为前缀，以日期为后缀从库必须以-s 为后缀备库必须以-ss 为后缀 三、表设计规范单实例表个数必须控制在 2000 个以内单表分表个数必须控制在 1024 个以内表必须有主键，推荐使用 UNSIGNED 整数为主键潜在坑：删除无主键的表，如果是 row 模式的主从架构，从库会挂住 禁止使用外键，如果要保证完整性，应由应用程式实现解读：外键使得表之间相互耦合，影响 update/delete 等 SQL 性能，有可能造成死锁，高并发情况下容易成为数据库瓶颈 建议将大字段，访问频度低的字段拆分到单独的表中存储，分离冷热数据解读：具体参加《如何实施数据库垂直拆分》 四、列设计规范根据业务区分使用 tinyint/int/bigint，分别会占用 1/4/8 字节根据业务区分使用 char/varchar解读：（1）字段长度固定，或者长度近似的业务场景，适合使用 char，能够减少碎片，查询性能高（2）字段长度相差较大，或者更新较少的业务场景，适合使用 varchar，能够减少空间 根据业务区分使用 datetime/timestamp解读：前者占用 5 个字节，后者占用 4 个字节，存储年使用 YEAR，存储日期使用 DATE，存储时间使用 datetime 必须把字段定义为 NOT NULL 并设默认值解读：（1）NULL 的列使用索引，索引统计，值都更加复杂，MySQL 更难优化（2）NULL 需要更多的存储空间（3）NULL 只能采用 IS NULL 或者 IS NOT NULL，而在=/!=/in/not in 时有大坑 使用 INT UNSIGNED 存储 IPv4，不要用 char(15)使用 varchar(20)存储手机号，不要使用整数解读：（1）牵扯到国家代号，可能出现+/-/()等字符，例如+86（2）手机号不会用来做数学运算（3）varchar 可以模糊查询，例如 like ‘138%’ 使用 TINYINT 来代替 ENUM解读：ENUM 增加新值要进行 DDL 操作 五、索引规范唯一索引使用 uniq_[字段名]来命名非唯一索引使用 idx_[字段名]来命名单张表索引数量建议控制在 5 个以内解读：（1）互联网高并发业务，太多索引会影响写性能（2）生成执行计划时，如果索引太多，会降低性能，并可能导致 MySQL 选择不到最优索引（3）异常复杂的查询需求，可以选择 ES 等更为适合的方式存储 组合索引字段数不建议超过 5 个解读：如果 5 个字段还不能极大缩小 row 范围，八成是设计有问题 不建议在频繁更新的字段上建立索引非必要不要进行 JOIN 查询，如果要进行 JOIN 查询，被 JOIN 的字段必须类型相同，并建立索引解读：踩过因为 JOIN 字段类型不一致，而导致全表扫描的坑么？ 理解组合索引最左前缀原则，避免重复建设索引，如果建立了(a,b,c)，相当于建立了(a), (a,b), (a,b,c) 六、SQL 规范禁止使用 select ，只获取必要字段解读：（1）select 会增加 cpu/io/内存/带宽的消耗（2）指定字段能有效利用索引覆盖（3）指定字段查询，在表结构变更时，能保证对应用程序无影响 insert 必须指定字段，禁止使用 insert into T values()解读：指定字段插入，在表结构变更时，能保证对应用程序无影响 隐式类型转换会使索引失效，导致全表扫描 禁止在 where 条件列使用函数或者表达式解读：导致不能命中索引，全表扫描 禁止负向查询以及%开头的模糊查询解读：导致不能命中索引，全表扫描 禁止大表 JOIN 和子查询同一个字段上的 OR 必须改写问 IN，IN 的值必须少于 50 个应用程序必须捕获 SQL 异常解读：方便定位线上问题说明：本文转自公众号“架构师之路”，扫描下面二维码关注有更多精彩内容。 Go &copy; 2019 GitHub, Inc. Terms Privacy Security Status Help Contact GitHub Pricing API Training Blog About You can’t perform that action at this time. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F07%2F21%2F2018-04-24-21%E5%88%86%E9%92%9FMysql%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[&lt;!DOCTYPE html&gt; zhangjinmiao.github.io/2018-04-24-21分钟Mysql教程.md at 444c91a5a1049ef043d2321f32c44628b7004182 · zhangjinmiao/zhangjinmiao.github.io Skip to content In this repository All GitHub ↵ Jump to ↵ No suggested jump to results In this repository All GitHub ↵ Jump to ↵ In this repository All GitHub ↵ Jump to ↵ Dashboard Pull requests Issues Marketplace Explore LouisTuo Sign out zhangjinmiao / zhangjinmiao.github.io New repository Import repository New gist New organization This repository New issue Signed in as LouisTuo 🎯 Focusing Edit status 🎯 🎯 Could not update your status, please try again. 80 remaining Suggestions: 🌴 On vacation 🤒 Out sick 🏠 Working from home 🎯 Focusing Busy When others mention you, assign you, or request your review, GitHub will let them know that you have limited availability. Clear status Never Never Keep this status until you clear your status or edit your status. in 30 minutes in 1 hour in 4 hours today this week Set status Clear status Your profile Your repositories Your projects Your stars Your gists Help Settings Sign out Watch Notifications Not watching Be notified only when participating or @mentioned. Watch Releases only Be notified of new releases, and when participating or @mentioned. Unwatch releases Watching Be notified of all conversations. Unwatch Ignoring Never be notified. Stop ignoring 1 Unstar 0 Star 0 Fork 0 zhangjinmiao/zhangjinmiao.github.io Code Issues 0 Pull requests 0 Projects 0 Wiki Security Insights Code Issues 0 Pull requests 0 Projects 0 Wiki Security Pulse Community Permalink Tree: 444c91a5a1 Find file Copy path zhangjinmiao.github.io/_posts/mysql/2018-04-24-21分钟Mysql教程.md Find file Copy path Fetching contributors&hellip; Cannot retrieve contributors at this time 559 lines (419 sloc) 19.3 KB Raw Blame History layout title categories description keywords post 21 分钟 MySQL 教程 MySQL mysql mysql, 21 分钟 为什么只需要 21 分钟呢？因为在我们大天朝有句话叫做三七二十一，你可以不管三七二十一开始使用 MySQL 及快速的方式入门 MySQL。其实 21 分钟把下面语句之行一遍是没有问题的，要理解的话估计不止 21 分钟，对于初学者来说只需满足自己需求可以增删改查等简易的维护即可。开始使用我下面所有的 SQL 语句是基于 MySQL 5.6+运行。MySQL 为关系型数据库(Relational Database Management System)，一个关系型数据库由一个或数个表格组成, 如图所示的一个表格：表头(header): 每一列的名称;列(col): 具有相同数据类型的数据的集合;行(row): 每一行用来描述某个人/物的具体信息;值(value): 行的具体信息, 每个值必须与该列的数据类型相同;键(key): 表中用来识别某个特定的人\物的方法, 键的值在当前列中具有唯一性。登录 MySQLmysql -h 127.0.0.1 -u 用户名 -pmysql -D 所选择的数据库名 -h 主机名 -u 用户名 -pmysql&gt; exit # 退出 使用 “quit;” 或 “\q;” 一样的效果mysql&gt; status; # 显示当前mysql的version的各种信息mysql&gt; select version(); # 显示当前mysql的version信息mysql&gt; show global variables like ‘port‘; # 查看MySQL端口号创建数据库对于表的操作需要先进入库use 库名;– 创建一个名为 samp_db 的数据库，数据库字符编码指定为 gbkcreate database samp_db character set gbk;drop database samp_db; – 删除 库名为samp_db的库show databases; – 显示数据库列表。use samp_db; – 选择创建的数据库samp_dbshow tables; – 显示samp_db下面所有的表名字describe 表名; – 显示数据表的结构delete from 表名; – 清空表中记录创建数据库表使用 create table 语句可完成对表的创建, create table 的常见形式:语法：create table 表名称(列声明);– 如果数据库中存在user_accounts表，就把它从数据库中drop掉DROP TABLE IF EXISTS &lt;/span&gt;user_accounts&lt;span class=&quot;pl-pds&quot;&gt;;CREATE TABLE &lt;span class=&quot;pl-en&quot;&gt;user_accounts&lt;/span&gt; ( &lt;/span&gt;id&lt;span class=&quot;pl-pds&quot;&gt; int(100) unsigned NOT NULL AUTO_INCREMENT primary key, &lt;/span&gt;password&lt;span class=&quot;pl-pds&quot;&gt; varchar(32) NOT NULL DEFAULT ‘‘ COMMENT ‘用户密码‘, &lt;/span&gt;reset_password&lt;span class=&quot;pl-pds&quot;&gt; tinyint(32) NOT NULL DEFAULT 0 COMMENT ‘用户类型：0－不需要重置密码；1-需要重置密码‘, &lt;/span&gt;mobile&lt;span class=&quot;pl-pds&quot;&gt; varchar(20) NOT NULL DEFAULT ‘‘ COMMENT ‘手机‘, &lt;/span&gt;create_at&lt;span class=&quot;pl-pds&quot;&gt; timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), &lt;/span&gt;update_at&lt;span class=&quot;pl-pds&quot;&gt; timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), – 创建唯一索引，不允许重复 UNIQUE INDEX idx_user_mobile(&lt;/span&gt;mobile&lt;span class=&quot;pl-pds&quot;&gt;))ENGINE=InnoDB DEFAULT CHARSET=utf8COMMENT=‘用户表信息‘;数据类型的属性解释NULL：数据列可包含 NULL 值；NOT NULL：数据列不允许包含 NULL 值；DEFAULT：默认值；PRIMARY：KEY 主键；AUTO_INCREMENT：自动递增，适用于整数类型；UNSIGNED：是指数值类型只能为正数；CHARACTER SET name：指定一个字符集；COMMENT：对表或者字段说明；增删改查SELECTSELECT 语句用于从表中选取数据。语法：SELECT 列名称 FROM 表名称语法：SELECT FROM 表名称– 表station取个别名叫s，表station中不包含 字段id=13或者14 的，并且id不等于4的 查询出来，只显示idSELECT s.id from station s WHERE id in (13,14) and id not in (4);– 从表 Persons 选取 LastName 列的数据SELECT LastName FROM Persons– 从表 users 选取 id=3 的数据，并只拉一条数据(据说能优化性能)SELECT FROM users where id=3 limit 1– 结果集中会自动去重复数据SELECT DISTINCT Company FROM Orders– 表 Persons 字段 Id_P 等于 Orders 字段 Id_P 的值，– 结果集显示 Persons表的 LastName、FirstName字段，Orders表的OrderNo字段SELECT p.LastName, p.FirstName, o.OrderNo FROM Persons p, Orders o WHERE p.Id_P = o.Id_P– gbk 和 utf8 中英文混合排序最简单的办法 – ci是 case insensitive, 即 “大小写不敏感”SELECT tag, COUNT(tag) from news GROUP BY tag order by convert(tag using gbk) collate gbk_chinese_ci;SELECT tag, COUNT(tag) from news GROUP BY tag order by convert(tag using utf8) collate utf8_unicode_ci;UPDATEUpdate 语句用于修改表中的数据。语法：UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值– update语句设置字段值为另一个结果取出来的字段update user set name = (select name from user1 where user1 .id = 1 )where id = (select id from user2 where user2 .name=‘小苏‘);– 更新表 orders 中 id=1 的那一行数据更新它的 title 字段UPDATE &lt;/span&gt;orders&lt;span class=&quot;pl-pds&quot;&gt; set title=‘这里是标题‘ WHERE id=1;INSERTINSERT INTO 语句用于向表格中插入新的行。语法：INSERT INTO 表名称 VALUES (值1, 值2,….)语法：INSERT INTO 表名称 (列1, 列2,…) VALUES (值1, 值2,….)– 向表 Persons 插入一条字段 LastName = JSLite 字段 Address = shanghaiINSERT INTO Persons (LastName, Address) VALUES (‘JSLite‘, ‘shanghai‘);– 向表 meeting 插入 字段 a=1 和字段 b=2INSERT INTO meeting SET a=1,b=2;– – SQL实现将一个表的数据插入到另外一个表的代码– 如果只希望导入指定字段，可以用这种方法：– INSERT INTO 目标表 (字段1, 字段2, …) SELECT 字段1, 字段2, … FROM 来源表;INSERT INTO orders (user_account_id, title) SELECT m.user_id, m.title FROM meeting m where m.id=1;– 向表 charger 插入一条数据，已存在就对表 charger 更新 type,update_at 字段；INSERT INTO &lt;/span&gt;charger&lt;span class=&quot;pl-pds&quot;&gt; (&lt;/span&gt;id&lt;span class=&quot;pl-pds&quot;&gt;,&lt;/span&gt;type&lt;span class=&quot;pl-pds&quot;&gt;,&lt;/span&gt;create_at&lt;span class=&quot;pl-pds&quot;&gt;,&lt;/span&gt;update_at&lt;span class=&quot;pl-pds&quot;&gt;) VALUES (3,2,‘2017-05-18 11:06:17‘,‘2017-05-18 11:06:17‘) ON DUPLICATE KEY UPDATE &lt;/span&gt;id&lt;span class=&quot;pl-pds&quot;&gt;=VALUES(&lt;/span&gt;id&lt;span class=&quot;pl-pds&quot;&gt;), &lt;/span&gt;type&lt;span class=&quot;pl-pds&quot;&gt;=VALUES(&lt;/span&gt;type&lt;span class=&quot;pl-pds&quot;&gt;), &lt;/span&gt;update_at&lt;span class=&quot;pl-pds&quot;&gt;=VALUES(&lt;/span&gt;update_at&lt;span class=&quot;pl-pds&quot;&gt;);DELETEDELETE 语句用于删除表中的行。语法：DELETE FROM 表名称 WHERE 列名称 = 值– 在不删除table_name表的情况下删除所有的行，清空表。DELETE FROM table_name– 或者DELETE FROM table_name– 删除 Person表字段 LastName = ‘JSLite’ DELETE FROM Person WHERE LastName = ‘JSLite‘– 删除 表meeting id 为2和3的两条数据DELETE from meeting where id in (2,3);WHEREWHERE 子句用于规定选择的标准。语法：SELECT 列名称 FROM 表名称 WHERE 列 运算符 值– 从表 Persons 中选出 Year 字段大于 1965 的数据SELECT FROM Persons WHERE Year&gt;1965AND 和 ORAND - 如果第一个条件和第二个条件都成立；OR - 如果第一个条件和第二个条件中只要有一个成立；AND– 删除 meeting 表字段 – id=2 并且 user_id=5 的数据 和– id=3 并且 user_id=6 的数据 DELETE from meeting where id in (2,3) and user_id in (5,6);– 使用 AND 来显示所有姓为 “Carter” 并且名为 “Thomas” 的人：SELECT FROM Persons WHERE FirstName=‘Thomas‘ AND LastName=‘Carter‘;OR– 使用 OR 来显示所有姓为 “Carter” 或者名为 “Thomas” 的人：SELECT FROM Persons WHERE firstname=‘Thomas‘ OR lastname=‘Carter‘ORDER BY语句默认按照升序对记录进行排序。ORDER BY - 语句用于根据指定的列对结果集进行排序。DESC - 按照降序对记录进行排序。ASC - 按照顺序对记录进行排序。– Company在表Orders中为字母，则会以字母顺序显示公司名称SELECT Company, OrderNumber FROM Orders ORDER BY Company– 后面跟上 DESC 则为降序显示SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC– Company以降序显示公司名称，并OrderNumber以顺序显示SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC, OrderNumber ASCININ - 操作符允许我们在 WHERE 子句中规定多个值。IN - 操作符用来指定范围，范围中的每一条，都进行匹配。IN 取值规律，由逗号分割，全部放置括号中。语法：SELECT “字段名”FROM “表格名”WHERE “字段名” IN (‘值一’, ‘值二’, …);– 从表 Persons 选取 字段 LastName 等于 Adams、CarterSELECT FROM Persons WHERE LastName IN (‘Adams‘,‘Carter‘)NOTNOT - 操作符总是与其他操作符一起使用，用在要过滤的前面。SELECT vend_id, prod_name FROM Products WHERE NOT vend_id = ‘DLL01‘ ORDER BY prod_name;UNIONUNION - 操作符用于合并两个或多个 SELECT 语句的结果集。– 列出所有在中国表（Employees_China）和美国（Employees_USA）的不同的雇员名SELECT E_Name FROM Employees_China UNION SELECT E_Name FROM Employees_USA– 列出 meeting 表中的 pic_url，– station 表中的 number_station 别名设置成 pic_url 避免字段不一样报错– 按更新时间排序SELECT id,pic_url FROM meeting UNION ALL SELECT id,number_station AS pic_url FROM station ORDER BY update_at;– 通过 UNION 语法同时查询了 products 表 和 comments 表的总记录数，并且按照 count 排序SELECT ‘product‘ AS type, count() as count FROM &lt;/span&gt;products&lt;span class=&quot;pl-pds&quot;&gt; union select ‘comment‘ as type, count() as count FROM &lt;/span&gt;comments&lt;span class=&quot;pl-pds&quot;&gt; order by count;ASas - 可理解为：用作、当成，作为；别名一般是重命名列名或者表名。语法：select column_1 as 列1,column_2 as 列2 from table as 表SELECT FROM Employee AS emp– 这句意思是查找所有Employee 表里面的数据，并把Employee表格命名为 emp。– 当你命名一个表之后，你可以在下面用 emp 代替 Employee.– 例如 SELECT FROM emp.SELECT MAX(OrderPrice) AS LargestOrderPrice FROM Orders– 列出表 Orders 字段 OrderPrice 列最大值，– 结果集列不显示 OrderPrice 显示 LargestOrderPrice– 显示表 users_profile 中的 name 列SELECT t.name from (SELECT from users_profile a) AS t;– 表 user_accounts 命名别名 ua，表 users_profile 命名别名 up– 满足条件 表 user_accounts 字段 id 等于 表 users_profile 字段 user_id– 结果集只显示mobile、name两列SELECT ua.mobile,up.name FROM user_accounts as ua INNER JOIN users_profile as up ON ua.id = up.user_id;JOIN用于根据两个或多个表中的列之间的关系，从这些表中查询数据。JOIN: 如果表中有至少一个匹配，则返回行INNER JOIN:在表中存在至少一个匹配时，INNER JOIN 关键字返回行。LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行FULL JOIN: 只要其中一个表中存在匹配，就返回行SELECT Persons.LastName, Persons.FirstName, Orders.OrderNoFROM PersonsINNER JOIN OrdersON Persons.Id_P = Orders.Id_PORDER BY Persons.LastName;SQL 函数COUNTCOUNT 让我们能够数出在表格中有多少笔资料被选出来。语法：SELECT COUNT(“字段名”) FROM “表格名”;– 表 Store_Information 有几笔 store_name 栏不是空白的资料。– “IS NOT NULL” 是 “这个栏位不是空白” 的意思。SELECT COUNT (Store_Name) FROM Store_Information WHERE Store_Name IS NOT NULL;– 获取 Persons 表的总数SELECT COUNT(1) AS totals FROM Persons;– 获取表 station 字段 user_id 相同的总数select user_id, count() as totals from station group by user_id;MAXMAX 函数返回一列中的最大值。NULL 值不包括在计算中。语法：SELECT MAX(“字段名”) FROM “表格名”– 列出表 Orders 字段 OrderPrice 列最大值，– 结果集列不显示 OrderPrice 显示 LargestOrderPriceSELECT MAX(OrderPrice) AS LargestOrderPrice FROM Orders触发器语法：create trigger &lt;触发器名称&gt;{ before | after} # 之前或者之后出发insert | update | delete # 指明了激活触发程序的语句的类型on &lt;表名&gt; # 操作哪张表for each row # 触发器的执行间隔，for each row 通知触发器每隔一行执行一次动作，而不是对整个表执行一次。&lt;触发器 SQL 语句&gt;delimiter $CREATE TRIGGER set_userdate BEFORE INSERTon &lt;/span&gt;message&lt;span class=&quot;pl-pds&quot;&gt;for EACH ROWBEGIN set @statu = new.status; – 声明复制变量 statu if @statu = 0 then – 判断 statu 是否等于 0 UPDATE &lt;/span&gt;user_accounts&lt;span class=&quot;pl-pds&quot;&gt; SET status=1 WHERE openid=NEW.openid; end if;END$DELIMITER ; – 恢复结束符号OLD 和 NEW 不区分大小写NEW 用 NEW.col_name，没有旧行。在 DELETE 触发程序中，仅能使用 OLD.col_name，没有新行。OLD 用 OLD.col_name 来引用更新前的某一行的列添加索引普通索引(INDEX)语法：ALTER TABLE 表名字 ADD INDEX 索引名字 ( 字段名字 )– –直接创建索引CREATE INDEX index_user ON user(title)– –修改表结构的方式添加索引ALTER TABLE table_name ADD INDEX index_name ON (column(length))– 给 user 表中的 name字段 添加普通索引(INDEX)ALTER TABLE &lt;/span&gt;table&lt;span class=&quot;pl-pds&quot;&gt; ADD INDEX index_name (name)– –创建表的时候同时创建索引CREATE TABLE &lt;span class=&quot;pl-en&quot;&gt;table&lt;/span&gt; ( &lt;/span&gt;id&lt;span class=&quot;pl-pds&quot;&gt; int(11) NOT NULL AUTO_INCREMENT , &lt;/span&gt;title&lt;span class=&quot;pl-pds&quot;&gt; char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL , &lt;/span&gt;content&lt;span class=&quot;pl-pds&quot;&gt; text CHARACTER SET utf8 COLLATE utf8_general_ci NULL , &lt;/span&gt;time&lt;span class=&quot;pl-pds&quot;&gt; int(10) NULL DEFAULT NULL , PRIMARY KEY (&lt;/span&gt;id&lt;span class=&quot;pl-pds&quot;&gt;), INDEX index_name (title(length)))– –删除索引DROP INDEX index_name ON table主键索引(PRIMARY key)语法：ALTER TABLE 表名字 ADD PRIMARY KEY ( 字段名字 )– 给 user 表中的 id字段 添加主键索引(PRIMARY key)ALTER TABLE &lt;/span&gt;user&lt;span class=&quot;pl-pds&quot;&gt; ADD PRIMARY key (id);唯一索引(UNIQUE)语法：ALTER TABLE 表名字 ADD UNIQUE (字段名字)– 给 user 表中的 creattime 字段添加唯一索引(UNIQUE)ALTER TABLE &lt;/span&gt;user&lt;span class=&quot;pl-pds&quot;&gt; ADD UNIQUE (creattime);全文索引(FULLTEXT)语法：ALTER TABLE 表名字 ADD FULLTEXT (字段名字)– 给 user 表中的 description 字段添加全文索引(FULLTEXT)ALTER TABLE &lt;/span&gt;user&lt;span class=&quot;pl-pds&quot;&gt; ADD FULLTEXT (description);添加多列索引语法：ALTER TABLE table_name ADD INDEX index_name ( column1, column2, column3)– 给 user 表中的 name、city、age 字段添加名字为name_city_age的普通索引(INDEX)ALTER TABLE user ADD INDEX name_city_age (name(10),city,age); 建立索引的时机在WHERE和JOIN中出现的列需要建立索引，但也不完全如此：MySQL 只对&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN使用索引某些时候的LIKE也会使用索引。在LIKE以通配符%和_开头作查询时，MySQL 不会使用索引。– 此时就需要对city和age建立索引，– 由于mytable表的userame也出现在了JOIN子句中，也有对它建立索引的必要。SELECT t.NameFROM mytable t LEFT JOIN mytable m ON t.Name=m.usernameWHERE m.age=20 AND m.city=‘上海‘;SELECT FROM mytable WHERE username like‘admin%‘; – 而下句就不会使用：SELECT FROM mytable WHEREt Name like‘%admin‘; – 因此，在使用LIKE时应注意以上的区别。索引的注意事项索引不会包含有 NULL 值的列使用短索引不要在列上进行运算 索引会失效创建后表的修改添加列语法：alter table 表名 add 列名 列数据类型 [after 插入位置];示例:– 在表students的最后追加列 address: alter table students add address char(60);– 在名为 age 的列后插入列 birthday: alter table students add birthday date after age;– 在名为 number_people 的列后插入列 weeks: alter table students add column &lt;/span&gt;weeks&lt;span class=&quot;pl-pds&quot;&gt; varchar(5) not null default ““ after &lt;/span&gt;number_people&lt;span class=&quot;pl-pds&quot;&gt;;修改列语法：alter table 表名 change 列名称 列新名称 新数据类型;– 将表 tel 列改名为 telphone: alter table students change tel telphone char(13) default “-“;– 将 name 列的数据类型改为 char(16): alter table students change name name char(16) not null;– 修改 COMMENT 前面必须得有类型属性alter table students change name name char(16) COMMENT ‘这里是名字‘;– 修改列属性的时候 建议使用modify,不需要重建表– change用于修改列名字，这个需要重建表alter table meeting modify &lt;/span&gt;weeks&lt;span class=&quot;pl-pds&quot;&gt; varchar(20) NOT NULL DEFAULT ““ COMMENT “开放日期 周一到周日：0~6，间隔用英文逗号隔开“;– user表的id列，修改成字符串类型长度50，不能为空，FIRST放在第一列的位置alter table &lt;/span&gt;user&lt;span class=&quot;pl-pds&quot;&gt; modify COLUMN &lt;/span&gt;id&lt;span class=&quot;pl-pds&quot;&gt; varchar(50) NOT NULL FIRST ;删除列语法：alter table 表名 drop 列名称;– 删除表students中的 birthday 列: alter table students drop birthday;重命名表语法：alter table 表名 rename 新表名;– 重命名 students 表为 workmates: alter table students rename workmates;清空表数据方法一：delete from 表名;方法二：truncate from “表名”;DELETE:1. DML 语言;2. 可以回退;3. 可以有条件的删除;TRUNCATE:1. DDL 语言;2. 无法回退;3. 默认所有的表内容都删除;4. 删除速度比 delete 快。– 清空表为 workmates 里面的数据，不删除表。 delete from workmates;– 删除workmates表中的所有数据，且无法恢复truncate from workmates;删除整张表语法：drop table 表名;– 删除 workmates 表: drop table workmates;删除整个数据库语法：drop database 数据库名;– 删除 samp_db 数据库: drop database samp_db;其它实例SQL 删除重复记录转载– 查找表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断select from people where peopleId in (select peopleId from people group by peopleId having count(peopleId) &gt; 1)– 删除表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断，只留有rowid最小的记录delete from peoplewhere peopleId in (select peopleId from people group by peopleId having count(peopleId) &gt; 1)and rowid not in (select min(rowid) from people group by peopleId having count(peopleId )&gt;1)– 查找表中多余的重复记录（多个字段）select from vitae awhere (a.peopleId,a.seq) in (select peopleId,seq from vitae group by peopleId,seq having count() &gt; 1)– 删除表中多余的重复记录（多个字段），只留有rowid最小的记录delete from vitae awhere (a.peopleId,a.seq) in (select peopleId,seq from vitae group by peopleId,seq having count() &gt; 1) and rowid not in (select min(rowid) from vitae group by peopleId,seq having count()&gt;1)– 查找表中多余的重复记录（多个字段），不包含rowid最小的记录select from vitae awhere (a.peopleId,a.seq) in (select peopleId,seq from vitae group by peopleId,seq having count() &gt; 1) and rowid not in (select min(rowid) from vitae group by peopleId,seq having count(*)&gt;1)参考手册http://www.w3school.com.cn/sql/index.asphttp://www.1keydata.com/cn/sql/sql-count.php Go &copy; 2019 GitHub, Inc. Terms Privacy Security Status Help Contact GitHub Pricing API Training Blog About You can’t perform that action at this time. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F07%2F21%2F2018-04-03-Mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[&lt;!DOCTYPE html&gt; zhangjinmiao.github.io/2018-04-03-Mysql查询优化.md at 444c91a5a1049ef043d2321f32c44628b7004182 · zhangjinmiao/zhangjinmiao.github.io Skip to content In this repository All GitHub ↵ Jump to ↵ No suggested jump to results In this repository All GitHub ↵ Jump to ↵ In this repository All GitHub ↵ Jump to ↵ Dashboard Pull requests Issues Marketplace Explore LouisTuo Sign out zhangjinmiao / zhangjinmiao.github.io New repository Import repository New gist New organization This repository New issue Signed in as LouisTuo 🎯 Focusing Edit status 🎯 🎯 Could not update your status, please try again. 80 remaining Suggestions: 🌴 On vacation 🤒 Out sick 🏠 Working from home 🎯 Focusing Busy When others mention you, assign you, or request your review, GitHub will let them know that you have limited availability. Clear status Never Never Keep this status until you clear your status or edit your status. in 30 minutes in 1 hour in 4 hours today this week Set status Clear status Your profile Your repositories Your projects Your stars Your gists Help Settings Sign out Watch Notifications Not watching Be notified only when participating or @mentioned. Watch Releases only Be notified of new releases, and when participating or @mentioned. Unwatch releases Watching Be notified of all conversations. Unwatch Ignoring Never be notified. Stop ignoring 1 Unstar 0 Star 0 Fork 0 zhangjinmiao/zhangjinmiao.github.io Code Issues 0 Pull requests 0 Projects 0 Wiki Security Insights Code Issues 0 Pull requests 0 Projects 0 Wiki Security Pulse Community Permalink Tree: 444c91a5a1 Find file Copy path zhangjinmiao.github.io/_posts/mysql/2018-04-03-Mysql查询优化.md Find file Copy path Fetching contributors&hellip; Cannot retrieve contributors at this time 542 lines (296 sloc) 18.6 KB Raw Blame History layout title categories description keywords post MySQL 查询优化 mysql mysql 查询优化 mysql, 优化 1. 数据库性能参数查询 mysql 数据库的一些运行状态show status; 查看操作次数show status like ‘Com_(CRUD)‘;查看 mysql 数据库启动多长时间，myisam 存储引擎长时间启动需要进行碎片整理show status like ‘uptime‘;查看慢查询show status like ‘slow_queries‘;查询慢查询时间show variables like ‘long_query_time‘;设置慢查询时间set long_query_time = 0.5;2. 查询优化2.1 查看 SQL 执行计划使用命令：EXPLAIN/DESCRIBE/DESCSELECT FROM…;2.2 每个字段说明id：SELECT 标识符。这是 SELECT 的查询序列号。select_type：表示 SELECT 语句的类型。它可以是以下几种取值：SIMPLE：表示简单查询，其中不包括连接查询和子查询；PRIMARY：表示主查询，或者最外层的查询语句；UNION：表示连接查询的第 2 个或后面的查询语句；DEPENDENT UNION：连接查询中的第 2 个或后面的 SELECT 语句，取决于外面的查询；UNION RESULT：连接查询的结果；SUBQUERY：子查询中的第一个 SELECT 语句；DEPENDENT SUBQUERY：子查询中的第一个 SELECT，取决于外面的查询；DERIVED：导出表的 SELECT (FROM 语句的子查询）。table：表示查询的表。type：（★重要★）表示表的连接类型。下面按照从最佳类型到最差类型的顺序给出各种连接类型：该表仅有一行的系统表。这是 const 连接类型的一个特例，平时不会出现，这个也可以忽略不计const：数据表最多只有一个匹配行，它将在查询开始时被读取，并在余下的査询优化中作为常量对待。const 表查询速度很快，因为它们只读取一次。const 用于使用常数值比较 PRIMARY KEY 或 UNIQUE 索引的所有部分的场合。在下面查询中，tb1_name 可用 const 表：SELECT from tb1_name WHERE primary_key=1;SELECT from tb1_name WHERE primary_key_part1=1 AND primary_key_part2=2​eq_refmysql 手册是这样说的:”对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的联接类型，除了 const 类型。它用在一个索引的所有部分被联接使用并且索引是 UNIQUE 或 PRIMARY KEY”。eq_ref 可以用于使用=比较带索引的列。在下面例子中，MySQL 可以使用 eq_ref 来处理 ref_tables： SELECT FROM ref_table,other_table WHERE ref_table.key_cloumn = other_table.cloumn; SELECT FROM ref_table, other_tbale WHERE ref_table.key_cloumn_part1 = other_table.cloumn AND ref_table.key_cloumn_part2 = 1;ref对于来自前面的表的任意组合，将从该表中读取所有匹配的行。这种类型用于索引既不是 UNIQUE 也不是 PRIMARY KEY 的情况，或者查询中使用了索引列在左子集，既索引中左边的部分列组合。ref 可以用于使用=或者&lt;=&gt;操作符的带索引的列。以下的几个例子中，mysql 将使用 ref 来处理 ref_table：select from ref_table where key_column=expr;select from ref_table,other_table where ref_table.key_column=other_table.column;select from ref_table,other_table where ref_table.key_column_part1=other_table.column and ref_table.key_column_part2=1;ref_or_null这种连接类型类似 ref，不同的是 mysql 会在检索的时候额外的搜索包含 null 值的记录。在解决子查询中经常使用该链接类型的优化。在以下的例子中，mysql 使用 ref_or_null 类型来处理 ref_table：select from ref_table where key_column=expr or key_column is null;上面这五种情况都是很理想的索引使用情况。index_merge该链接类型表示使用了索引合并优化方法。在这种情况下，key 列包含了使用的索引的清单，key_len 包含了使用的索引的最长的关键元素。unique_subquery该类型替换了下面形式的 IN 子查询的 ref：value in (select primary_key from single_table where some_expr)index_subquery这种连接类型类似 unique_subquery。可以替换 IN 子查询，不过它用于在子查询中没有唯一索引的情况下，例如以下形式：value in (select key_column from single_table where some_expr)range只检索给定范围的行，使用一个索引来选择行。key 列显示使用了哪个索引。ken_len 包含所使用索引的最长关键元素。当使用 =, &lt;&gt;, &gt;,&gt;=, &lt;, &lt;=, is null, &lt;=&gt;, between, 或 in 操作符，用常量比较关键字列时，类型为 range。下面介绍几种检索制定行的情况：select from tbl_name where key_column = 10;select from tbl_name where key_column between 10 and 20;select from tbl_name where key_column in (10,20,30);select from tbl_name where key_part1= 10 and key_part2 in (10,20,30);​index连接类型跟 ALL 一样，不同的是它只扫描索引树。它通常会比 ALL 快点，因为索引文件通常比数据文件小。ALL （性能最差）对于前面的表的任意行组合，进行完整的表扫描。如果第一个表没有被标识为 const 的话就不大好了，在其他情况下通常是非常糟糕的。正常地，可以通过增加索引使得能从表中更快的取得记录以避免 ALL。possible_keyspossible_keys 字段是指 MySQL 在搜索表记录时可能使用哪个索引。如果这个字段的值是 NULL，就表示没有索引被用到。这种情况下，就可以检查 WHERE 子句中哪些字段哪些字段适合增加索引以提高查询的性能。创建一下索引，然后再用 explain 检查一下。keykey 字段显示了 MySQL 实际上要用的索引。当没有任何索引被用到的时候，这个字段的值就是 NULL。想要让 MySQL 强行使用或者忽略在 possible_keys 字段中的索引列表，可以在查询语句中使用关键字 force index, use index 或 ignore index。参考 SELECT 语法。key_len​key_len 字段显示了 mysql 使用索引的长度。当 key 字段的值为 NULL 时，索引的长度就是 NULL。注意，key_len 的值可以告诉你在联合索引中 MySQL 会真正使用了哪些索引。ref​表示使用哪个列或常数与索引一起来查询记录。rows显示 MySQL 在表中进行查询时必须检查的行数。Extra本字段显示了查询中 mysql 的附加信息。以下是这个字段的几个不同值的解释：distinctMySQL 当找到当前记录的匹配联合结果的第一条记录之后，就不再搜索其他记录了。not existsMySQL 在查询时做一个 LEFT JOIN 优化时，当它在当前表中找到了和前一条记录符合 LEFT JOIN 条件后，就不再搜索更多的记录了。下面是一个这种类型的查询例子：select from t1 left join t2 on t1.id=t2.id where t2.id is null;假使 t2.id 定义为 not null。这种情况下，MySQL 将会扫描表 t1 并且用 t1.id 的值在 t2 中查找记录。当在 t2 中找到一条匹配的记录时，这就意味着 t2.id 肯定不会都是 null，就不会再在 t2 中查找相同 id 值的其他记录了。也可以这么说，对于 t1 中的每个记录，mysql 只需要在 t2 中做一次查找，而不管在 t2 中实际有多少匹配的记录。range checked for each record (index map: #)MySQL 没找到合适的可用的索引。取代的办法是，对于前一个表的每一个行连接，它会做一个检验以决定该使用哪个索引（如果有的话），并且使用这个索引来从表里取得记录。这个过程不会很快，但总比没有任何索引时做表连接来得快。using filesortMySQL 需要额外的做一遍从已排好的顺序取得记录。排序程序根据连接的类型遍历所有的记录，并且将所有符合 where 条件的记录的要排序的键和指向记录的指针存储起来。这些键已经排完序了，对应的记录也会按照排好的顺序取出来。using index字段的信息直接从索引树中的信息取得，而不再去扫描实际的记录。这种策略用于查询时的字段是一个独立索引的一部分。using temporaryMySQL 需要创建临时表存储结果以完成查询。这种情况通常发生在查询时包含了 group by 和 order by 子句，它以不同的方式列出了各个字段。using wherewhere 子句将用来限制哪些记录匹配了下一个表或者发送给客户端。除非你特别地想要取得或者检查表中的所有记录，否则的话当查询的 extra 字段值不是 using where 并且表连接类型是 all 或 index 时可能表示有问题。Using sort_union(…), Using union(…), Using intersect(…)这些函数说明如何为 index_merge 联接类型合并索引扫描�Using index for group-by类似于访问表的 Using index 方式,Using index for group-by 表示 MySQL 发现了一个索引,可以用来查 询 GROUP BY 或 DISTINCT 查询的所有列,而不要额外搜索硬盘访问实际的表。如果你想要让查询尽可能的快，那么就应该注意 extra 字段的值为 using filesort 和 using temporary 的情况。 说明 SQL 需要优化了。2.3 使用索引查询需要注意索引可以提供查询的速度，但并不是使用了带有索引的字段查询都会生效，有些情况下是不生效的，需要注意。2.3.1 使用 LIKE 关键字的查询在使用 LIKE 关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引不起作用。只有“%”不在第一个位置，索引才会生效。2.3.2 使用联合索引的查询MySQL 可以为多个字段创建索引，一个索引可以包括 16 个字段。对于联合索引，只有查询条件中使用了这些字段中第一个字段时，索引才会生效。2.3.3 使用 OR 关键字的查询查询语句的查询条件中只有 OR 关键字，且 OR 前后的两个条件中的列都是索引时，索引才会生效，否则，索引不生效。2.4 子查询优化MySQL 从 4.1 版本开始支持子查询，使用子查询进行 SELECT 语句嵌套查询，可以一次完成很多逻辑上需要多个步骤才能完成的 SQL 操作。子查询虽然很灵活，但是执行效率并不高。执行子查询时，MYSQL 需要创建临时表，查询完毕后再删除这些临时表，所以，子查询的速度会受到一定的影响。 优化：可以使用连接查询（JOIN）代替子查询，连接查询时不需要建立临时表，其速度比子查询快。3. 数据库结构优化一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。3.1 将字段很多的表分解成多个表对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。3.2 增加中间表对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。3.3 增加冗余字段设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。注意：冗余字段的值在一个表中修改，就要想办法在其他表中更新，否则就会导致数据不一致的问题。4. 插入数据的优化插入数据时，影响插入速度的主要是索引、唯一性校验、一次插入的数据条数等。 插入数据的优化，不同的存储引擎优化手段不一样，在 MySQL 中常用的存储引擎有，MyISAM 和 InnoDB，两者的区别：参考：http://www.cnblogs.com/panfeng412/archive/2011/08/16/2140364.html4.1 MyISAM4.1.1 禁用索引对于非空表，插入记录时，MySQL 会根据表的索引对插入的记录建立索引。如果插入大量数据，建立索引会降低插入数据速度。为了解决这个问题，可以在批量插入数据之前禁用索引，数据插入完成后再开启索引。禁用索引的语句：ALTER TABLE table_name DISABLE KEYS开启索引语句：ALTER TABLE table_name ENABLE KEYS对于空表批量插入数据，则不需要进行操作，因为 MyISAM 引擎的表是在导入数据后才建立索引。4.1.2 禁用唯一性检查唯一性校验会降低插入记录的速度，可以在插入记录之前禁用唯一性检查，插入数据完成后再开启。 禁用唯一性检查的语句：SET UNIQUE_CHECKS = 0; 开启唯一性检查的语句:SET UNIQUE_CHECKS = 1;4.1.3 批量插入数据插入数据时，可以使用一条 INSERT 语句插入一条数据，也可以插入多条数据。第二种方式的插入速度比第一种方式快。4.1.4 使用 LOAD DATA INFILE当需要批量导入数据时，使用 LOAD DATA INFILE 语句比 INSERT 语句插入速度快很多。4.2 InnoDB4.2.1 禁用唯一性检查用法和 MyISAM 一样。4.2.2 禁用外键检查插入数据之前执行禁止对外键的检查，数据插入完成后再恢复，可以提供插入速度。禁用：SET foreign_key_checks = 0;开启：SET foreign_key_checks = 1;4.2.3 禁止自动提交插入数据之前执行禁止事务的自动提交，数据插入完成后再恢复，可以提高插入速度。 禁用：SET autocommit = 0;开启：SET autocommit = 1;5. 服务器优化5.1 优化服务器硬件服务器的硬件性能直接决定着 MySQL 数据库的性能，硬件的性能瓶颈，直接决定 MySQL 数据库的运行速度和效率。 需要从以下几个方面考虑：1、 配置较大的内存。足够大的内存，是提高 MySQL 数据库性能的方法之一。内存的 IO 比硬盘快的多，可以增加系统的缓冲区容量，使数据在内存停留的时间更长，以减少磁盘的 IO。2、 配置高速磁盘，比如 SSD。3、 合理分配磁盘 IO，把磁盘 IO 分散到多个设备上，以减少资源的竞争，提高并行操作能力。4、 配置多核处理器，MySQL 是多线程的数据库，多处理器可以提高同时执行多个线程的能力。5.2 优化 MySQL 参数通过优化 MySQL 的参数可以提高资源利用率，从而达到提高 MySQL 服务器性能的目的。MySQL 的配置参数都在 my.conf 或者 my.ini 文件的 [mysqld] 组中，常用的参数如下：6. 优化 LIMIT 分页在分页偏移量很大的时候，如 LIMIT 10000,20 这样的查询，MySQL 需要查询 10020 条记录然后只返回最后 20 条，前面 10000 条记录都被抛弃，这样代价非常高。优化的最简单的办法就是尽可能地使用索引覆盖扫描，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列，对于偏移量很大的时候，这样做的效率回提升很大，如下：SELECT file_id, description FROM film ORDER BY title LIMIT 50, 5;修改为：SELECT film.film_id, film.description FROM filmINNER JOIN (SELCT film_id FROM film ORDER BY title LIMIT 50, 5) AS lim USING(film_id);这里“延迟关联”将大大提升查询效率，它让 MySQL 扫描尽可能少的页面，获取需要访问的记录后在根据关联列回原表查询需要的所有列。 Go &copy; 2019 GitHub, Inc. Terms Privacy Security Status Help Contact GitHub Pricing API Training Blog About You can’t perform that action at this time. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F07%2F21%2F2018-04-03-Mysql%2F</url>
    <content type="text"><![CDATA[&lt;!DOCTYPE html&gt; zhangjinmiao.github.io/2018-04-03-Mysql.md at 444c91a5a1049ef043d2321f32c44628b7004182 · zhangjinmiao/zhangjinmiao.github.io Skip to content In this repository All GitHub ↵ Jump to ↵ No suggested jump to results In this repository All GitHub ↵ Jump to ↵ In this repository All GitHub ↵ Jump to ↵ Dashboard Pull requests Issues Marketplace Explore LouisTuo Sign out zhangjinmiao / zhangjinmiao.github.io New repository Import repository New gist New organization This repository New issue Signed in as LouisTuo 🎯 Focusing Edit status 🎯 🎯 Could not update your status, please try again. 80 remaining Suggestions: 🌴 On vacation 🤒 Out sick 🏠 Working from home 🎯 Focusing Busy When others mention you, assign you, or request your review, GitHub will let them know that you have limited availability. Clear status Never Never Keep this status until you clear your status or edit your status. in 30 minutes in 1 hour in 4 hours today this week Set status Clear status Your profile Your repositories Your projects Your stars Your gists Help Settings Sign out Watch Notifications Not watching Be notified only when participating or @mentioned. Watch Releases only Be notified of new releases, and when participating or @mentioned. Unwatch releases Watching Be notified of all conversations. Unwatch Ignoring Never be notified. Stop ignoring 1 Unstar 0 Star 0 Fork 0 zhangjinmiao/zhangjinmiao.github.io Code Issues 0 Pull requests 0 Projects 0 Wiki Security Insights Code Issues 0 Pull requests 0 Projects 0 Wiki Security Pulse Community Permalink Tree: 444c91a5a1 Find file Copy path zhangjinmiao.github.io/_posts/mysql/2018-04-03-Mysql.md Find file Copy path zhangjinmiao guifan 444c91a Mar 23, 2019 1 contributor Users who have contributed to this file 68 lines (46 sloc) 2.21 KB Raw Blame History layout title categories description keywords post MySQL 小记 MySQL mysql mysql, 表设计 1. InnoDB 表如何设计主键索引建表语句：a 表：CREATE TABLE &lt;span class=&quot;pl-en&quot;&gt;a&lt;/span&gt; (&lt;/span&gt;id&lt;span class=&quot;pl-pds&quot;&gt; bigint(20) NOT NULL AUTO_INCREMENT,&lt;/span&gt;message_id&lt;span class=&quot;pl-pds&quot;&gt; int(11) NOT NULL,&lt;/span&gt;user_id&lt;span class=&quot;pl-pds&quot;&gt; int(11) NOT NULL,&lt;/span&gt;msg&lt;span class=&quot;pl-pds&quot;&gt; varchar(1024) DEFAULT NULL,&lt;/span&gt;gmt_create&lt;span class=&quot;pl-pds&quot;&gt; datetime NOT NULL,PRIMARY KEY (&lt;/span&gt;id&lt;span class=&quot;pl-pds&quot;&gt;),KEY &lt;/span&gt;user_id&lt;span class=&quot;pl-pds&quot;&gt; (&lt;/span&gt;user_id&lt;span class=&quot;pl-pds&quot;&gt;,&lt;/span&gt;message_id&lt;span class=&quot;pl-pds&quot;&gt;),KEY &lt;/span&gt;idx_gmt_create&lt;span class=&quot;pl-pds&quot;&gt; (&lt;/span&gt;gmt_create&lt;span class=&quot;pl-pds&quot;&gt;)) ENGINE=InnoDB DEFAULT CHARSET=gbk;b 表：CREATE TABLE &lt;span class=&quot;pl-en&quot;&gt;b&lt;/span&gt; (&lt;/span&gt;user_id&lt;span class=&quot;pl-pds&quot;&gt; int(11) NOT NULL,&lt;/span&gt;message_id&lt;span class=&quot;pl-pds&quot;&gt; int(11) NOT NULL,&lt;/span&gt;msg&lt;span class=&quot;pl-pds&quot;&gt; varchar(1024) DEFAULT NULL,&lt;/span&gt;gmt_create&lt;span class=&quot;pl-pds&quot;&gt; datetime NOT NULL,PRIMARY KEY (&lt;/span&gt;user_id&lt;span class=&quot;pl-pds&quot;&gt;,&lt;/span&gt;message_id&lt;span class=&quot;pl-pds&quot;&gt;),KEY &lt;/span&gt;idx_gmt_create&lt;span class=&quot;pl-pds&quot;&gt; (&lt;/span&gt;gmt_create&lt;span class=&quot;pl-pds&quot;&gt;)) ENGINE=InnoDB DEFAULT CHARSET=gbk;a 表和 b 表区别：记录空间优点缺点适用场景A 表500 万（顺序）509 M主键 ID 自增,在写入数据的候，Btree 分裂成本低，写性能高物理空间相对较多，如果根据 user_id 来查记录，需要走两次 IO写操作较多B 表500 万（随机）361 M1.物理空间相对减少 2.根据 user_id 查数据,直接走主键拿到数据，无需回表(user_id,message_id)为随机写入,Btree 分裂成本高,写性能低写少读多的场景，例如从hadoop回流到MySQL的统计结果表，这种统计结果一般数据较多，但主要是读2. 字符串索引隐式转换字段类型为字符串，查询时使用 数值型，该字段所在的索引不会用到。数字类型的 0001 等价于 1字符串的 0001 和 1 不等值当字符串的列有对应的索引，而在 where 条件里面不指定为字符串， index 无法确认最终的记录被隐式转换后，会进行全表遍历建表需要注意对应好字段类型​ Go &copy; 2019 GitHub, Inc. Terms Privacy Security Status Help Contact GitHub Pricing API Training Blog About You can’t perform that action at this time. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session.]]></content>
  </entry>
  <entry>
    <title><![CDATA[NodeJs]]></title>
    <url>%2F2018%2F10%2F08%2FNodejs%2F</url>
    <content type="text"><![CDATA[Node.js Node js模块 http模块 断言 – assert 二进制， File system JS 单线程，单进 Crypto –签名 HTTP/HTTPSHTTP2.0 os Path Events事件]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js笔记]]></title>
    <url>%2F2018%2F10%2F07%2FJs%2F</url>
    <content type="text"><![CDATA[js笔记 thisthis代表当前对象，但是在事件中代表的是当前对象 排他性 使用id或者index 123456789window.onload = function () &#123; var button = document.getElementsByClassName("button"); for(var i = 0; i&lt;button.length;i++)&#123; //异步 button[i].id = i; button[i].onclick = function () &#123; alert("你点了"+this.id+"按钮"); &#125; &#125; &#125; 使用闭包 12345678910window.onload = function () &#123; var button = document.getElementsByClassName("button"); for(var i = 0; i&lt;button.length;i++)&#123; //异步 (function (i) &#123; button[i].onclick = function () &#123; alert("你点了"+i+"按钮"); &#125; &#125;)(i); &#125; &#125; 数组高级API 1234567891011121314151617181920//1.判断数组类型var arr = [1,2,4];console.log(typeof arr); //objectconsole.log(arr instanceof Array); //truevar arr2 = new Array();console.log(Array.isArray(arr2)); //Array判断是否是数组//2.toString 转化成string，每个用，分割var arr3 = [1,3,"我是","hello"];console.log(arr3.toString()); //3. valueOf() 返回数组对象本身var arr4 = arr.valueOf();console.log(arr4);//4.join() 方法用于把数组中的所有元素放入一个字符串var arr5 = arr3.join("-");console.log(arr5);//5.indexOf()和lastIndexOf() 字符串string]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试插入图片]]></title>
    <url>%2F2018%2F10%2F07%2FTest%2F</url>
    <content type="text"><![CDATA[引入图片]]></content>
  </entry>
  <entry>
    <title><![CDATA[Markdown用法]]></title>
    <url>%2F2018%2F10%2F06%2FMarkdown%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Markdown用法 三级标题 序号 序号 序号 序号 代码块1console.log("hello world"); 1select * from reportmgr.tbl_day_alarm 1System.out.println("Hello world");]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6笔记]]></title>
    <url>%2F2018%2F10%2F06%2FES6%2F</url>
    <content type="text"><![CDATA[ES61.兼容性 编译和转换： 在线编译 提前编译 2.ES6语法 变量 函数 数组 字符串 面向对象 Promise generator 模块化 3.通信相关12345数据交互的几种方式:1. 表单2. Ajax，麻烦，安全3. JsonP，简单，有风险4. WebSocket 但是对于浏览器来说，区分不开，是form，还是ajax，还是jsonP 表单提交, 属性action: 提交到哪里method: GET,POST,PUT, 自定义name: 必须加，可以重复submit 提交按钮 数据提交方法 GET 数据放在URL中 容量有限 2. 看得见 3.有缓存 POST 数据放在http-body中 容量很大 2.看不见 3.不缓存 Ajax和表单提交对比： Ajax 用户体验好 表单提交 稳定（ajax是js提交，表单是浏览器提交） Ajax到底怎么回事呢？123456789101112131415161718192021222324252627282930//-----get------ //1. 创建异步对象 var xhr = new XMLHttpRequest(); //2. 连接 xhr.open('get','register.acion?usrname=xx',true); //3. 发送 xhr.send(); //4. 接收 xhr.onreadystatechange = function () &#123; // readyState通信状态 //status，http状态码 if(xhr.readyState==4 &amp;&amp; xhr.status==200)&#123; console.log(xhr.responseText); &#125; &#125;//-------post---------- //创建异步对象 var xhr = new XMLHttpRequest(); //设置请求的类型及url //post请求一定要添加请求头才行不然会报错 xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded"); xhr.open('post', '02.post.php' ); //发送请求 xhr.send('name=fox&amp;age=18'); xhr.onreadystatechange = function () &#123; // 这步为判断服务器是否正确响应 if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; console.log(xhr.responseText); &#125; &#125;; ajax，缓存ajax 跨域 -CORS跨域formData – Ajax2.0 WebSocket http状态码 1xx 消息 2xx 成功 3xx 重定向 （301 永久重定向 302 临时重定向 304） 4xx 请求错误(客户端) 5xx 服务端错误 6xx 扩展 转发和重定向 转发: 在服务器内部，转交给另外一个服务处理 – 地址不变 重定向：给浏览器下命令，让浏览器请求另外一个地址 –地址可变 进程和线程进程拥有独立的执行空间、存储同一个进程内的所有线程共享一套空间、代码 多进程 成本高（慢），安全（进程隔离），进程间通信麻烦，写代码简单 多线程 成本低（块），不安全（要死都死了），线程间通信容易，写代码复杂 多进程 慢，简单，安全 PHP，Node多线程 快，复杂，脆弱 Java，C]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
</search>
